# Copyright (c) 2022 Nik Silver
#
# This source code is released for free distribution under the terms of the
# GNU General Public License version 2 or later.
#
# Elmish tags format:
#   Kinds
#   - m module
#   - n namespace (ie a module that's renamed)
#   - t type
#   - c constructor (within a type)
#   - a alias
#   - p port
#   - f function
#   Key/value pairs
#   - roles:def    This tag is defined here
#   - roles:imported    This tag is imported here
#   - type:Thing    This constructor is of type Thing.
#
# To do:
# - Records as type annotations and parameters
# - Custom types
#   - Have type parameters as it signature
# - Constructor
#   - Add signatures to constructors
# - Functions
#   - Move the signature from the function to the
#     type annotation


%prefix "pelmish"

%auxil	"struct parserCtx *"

%earlysource {
    #include "general.h"
}

%header {
	struct parserCtx;

    // Remember the scope of the module tag. But at first there is none (CORK_NIL).
    int elm_module_scope_index;
}

%source {
#include "elmish_pre.h"
#include "routines.h"

// From https://github.com/arithy/packcc#macros
// This will output parsing info to STDERR.tmp in the vent of a failed test.

static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", \
        (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)

#define ELM_INIT_MODULE_SCOPE \
        elm_module_scope_index = CORK_NIL
#define ELM_SAVE_MODULE_SCOPE \
    if (elm_module_scope_index != CORK_NIL) { \
        POP_SCOPE(auxil); \
    }
#define ELM_RESTORE_MODULE_SCOPE \
    if (elm_module_scope_index != CORK_NIL) { \
        SET_SCOPE(auxil, elm_module_scope_index); \
    }
}

# Top level elements -----------------------------------------------------

# We separate the file into the module section and the main section
# so that we only consider and tag one module declaration

file <-
    {
        ELM_INIT_MODULE_SCOPE;
    }
    TLSS?
    moduleDeclaration?
    TLSS?
    mainTopLevelStatements?
    TLSS?
    EOF

mainTopLevelStatements <-
    topLevelStatement (TLSS mainTopLevelStatements)*

topLevelStatement <-
    importStatement
    / typeAlias
    / customType
    / functionWithTypeAnnotation
    / functionDefinition
    / ignoreRestOfStatement

# Main Elm grammar -------------------------------------------------------

moduleDeclaration <-
    'module' _1_ <dottedIdentifier> _1_ 'exposing' _0_ '(' exposedList ')' {
        elm_module_scope_index = makeElmTagSettingScope(auxil, $1, $1s, K_MODULE, ROLE_DEFINITION_INDEX);
    }

typeAlias <-
    'type' _1_ 'alias' _1_ <identifier> _0_ '=' _0_ ignoreRestOfStatement {
        makeElmTag(auxil, $1, $1s, K_ALIAS, ROLE_DEFINITION_INDEX);
    }

customType <-
    'type' _1_ <identifier> (_0_ typeParameterList)? _0_ '=' _0_ {
        makeElmTagSettingScope(auxil, $1, $1s, K_TYPE, ROLE_DEFINITION_INDEX);
    } constructorList {
        POP_KIND(auxil, true);
    }

importStatement <-
    'import' _1_ <dottedIdentifier> (_1_ 'as' _1_ <identifier>)? {
        // Make the namespace tag first, as it's in the file module's scope
        if ($2) {
            makeElmTag(auxil, $2, $2s, K_NAMESPACE, ROLE_DEFINITION_INDEX);
        }

        // Now make the tag for the imported module, as it lives outside
        // the scope of the file module
        ELM_SAVE_MODULE_SCOPE;
        makeElmTagSettingScope(auxil, $1, $1s, K_MODULE, ELM_ROLE_IMPORTED);
    } _1_ ('exposing' _0_ '(' _0_ importedList _0_ ')')? {
        ELM_RESTORE_MODULE_SCOPE;
    }

# A function with a type annotation.
#
# The type is on one line, and the function must follow immediately as
# the next top level statement

functionWithTypeAnnotation <-
    <identifier> _0_ ':' _0_ <typeAnnotation> TLSS
    <$1> _1_ ignoreToEquals '=' _0_ ignoreRestOfStatement {
        int r = makeElmTag(auxil, $3, $3s, K_FUNCTION, ROLE_DEFINITION_INDEX);
        addElmSignature(r, $2);
    }

typeAnnotation <-
    singleTypeSpec (_0_ '->' _0_ singleTypeSpec)*

ignoreToEquals <-
    &'='
    / !TLSS . ignoreToEquals

# A simple function definition

functionDefinition <-
    <identifier> _0_ parameterList? _0_ '=' _0_ ignoreRestOfStatement {
        makeElmTag(auxil, $1, $1s, K_FUNCTION, ROLE_DEFINITION_INDEX);
    }

# Sometimes we just need to ignore the rest of the (top level) statement

ignoreRestOfStatement <-
    (multilineString / Non_WS_or_NL+) (_1_ ignoreRestOfStatement)*

# Mid level tokens -------------------------------------------------------

# Module declaration
#
# We can be a bit relaxed about distinguishing functions, types and
# constructors, because we're not going to tag them.

dottedIdentifier <- identifier ('.' identifier)*

exposedList <- _0_ exposedItem _0_ (',' _0_ exposedList )*

exposedItem <-
    exposedFieldOrType
    / exposedItemIgnored

exposedFieldOrType <-
    <identifier> (_0_ '(' _0_ exposedTypeConstructorList _0_ ')')?

exposedItemIgnored <- '.'+

exposedTypeConstructorList <-
    (identifier / exposedItemIgnored) _0_ (',' _0_ exposedTypeConstructorList)*

# Import statement
#
# If we have a module Main with import statement
# 'import MyMod as MM exposing (Type(Constr))' it's not useful to mark MyMod,
# Type or Constr to be in module Main. However, Type is in the scope of
# MyMod, and Constr is in the scope of Type. They all have role 'imported'.
# On the other hand, MM is a namespace that is defined for Main, so it is
# useful to say it's in the scope of that.

importedList <- importedItem _0_ (',' _0_ importedList)*

importedItem <-
    importedFunction
    / importedType
    / importedItemIgnored

importedFunction <- <lowerStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_IMPORTED);
    }

importedType <-
    <upperStartIdentifier> {
        makeElmTagSettingScope(auxil, $1, $1s, K_TYPE, ELM_ROLE_IMPORTED);
    } (_0_ '(' _0_ importedTypeConstructorList _0_ ')')? {
        // We're done with the type and its constructors, so we can pop it
        POP_SCOPE(auxil);
    }

importedItemIgnored <- '.'+

importedTypeConstructorList <-
    (importedTypeConstructor / importedItemIgnored) _0_ (',' _0_ importedTypeConstructorList)*

importedTypeConstructor <-
    <upperStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ELM_ROLE_IMPORTED);
    }

# Type parameters, such as 'x' in 'type MyType x = Wrap x'
# We will be forgiving about capitalisation, although the compiler
# will insist on lower case parameter identifiers.

typeParameterList <- identifier (_1_ identifier)*

# A type could be defined as a constructor list:
#     type A = Cons1 String | Cons2 Float Float | ...
# The 'String' and the 'Float Float' etc are the constructor types.
# Each 'String', 'Float', etc is a single type spec.
# But a single type spec could also be a record, a tuple or a function spec.

constructorList <- <identifier> _0_ constructorTypes? _0_ ('|' _0_ constructorList)? {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ROLE_DEFINITION_INDEX);
}

constructorTypes <- singleTypeSpec (_0_ constructorTypes)*

singleTypeSpec <-
    recordTypeSpec
    / tupleTypeSpec
    / functionTypeSpec
    / dottedIdentifier

recordTypeSpec <-
    '{' _0_ fieldSpec (_0_ ',' _0_ fieldSpec)* _0_ '}'
    / '{' _0_ '}'

fieldSpec <-
    identifier _0_ ':' _0_ singleTypeSpec

tupleTypeSpec <-
    '(' _0_ singleTypeSpec (_0_ ',' _0_ singleTypeSpec)* _0_ ')'
    / '(' _0_ ')'

functionTypeSpec <-
    singleTypeSpec (_0_ '->' _0_ singleTypeSpec)*

# For the signature field, we should exclude leading and trailing whitespace

parameterList <-
    ( literal _1_ parameterList )+
    / literal

multilineString <-
    '"""' (!'"""' .)* '"""'

# Low level tokens

identifier <- [A-Za-z_] [A-Za-z0-9_]*

upperStartIdentifier <- [A-Z] [A-Za-z0-9_]*

lowerStartIdentifier <- [a-z_] [A-Za-z0-9_]*

literal <- identifier / [0-9]+

# Ignorable things -------------------------------------------------------

# Simple things...

WS <- [ \t]+
NL <- '\n' / '\f' / '\r' '\n'?
Non_NL <- [^\n\r\f]
Non_WS_or_NL <- [^ \t\n\r\f]
EOF <- !.

# End of line marks the end of the line, but doesn't include any newline

# EOL <- &NL / EOF

# A delimited comment is effectively "nothing", even if it spans several
# lines. But it does separate two tokens.
# A line comment can only come at the end of a line. Notice here it doesn't
# include the actual newline.

delimitedComment <- '{-' (delimitedComment / !'-}' .)* '-}'

lineComment <- '--' Non_NL*

# Elm whitespacing is a bit special...
# - Two statements are at the same level (eg at the top level, or statements
#   in the same let...in block) only if they being with the same indentation.
# - If meaningful code has more indentation than the previous line then it is
#   part of that previous line's statement.
# - But sometimes several statements can appear on the same line if tokens
#   make it obvious. Eg this is okay:
#   Eg: 'myFunc = let f x y = x + y in f 3 4'
#
# We'll only worry about top level statements in this parser, otherwise it
# gets too complicated. (Something to improve for the future.) But we still
# need to know
# - when a top level statement begins; and
# - when two sequential tokens are part of the same top level statement.
#   They may be separated by a combination of whitespace, comments, and
#   newlines, but there will be an indent at the end.
#
# When considering how tokens string together, we should only need three
# kinds of "join"s:
# - Where we need whitespace, such as 'import MyModule', but that space
#   may occur over multiple lines. If it's over multiple lines, the
#   second token needs to be somewhat in from the first column of text.
#   We'll call this _1_.
# - Where we don't need whitespace, such as 'f = 3', but that space
#   may occur over multiple lines. If it's over multiple lines then again
#   the second token needs to be somewhat in from the first column of text.
#   We'll call this _0_.
# - When we've got an end of statement, and the second token is some
#   meaningful code (not a comment) and starts in the first column of text.
#   We'll call this TLSS, for top level statement separator.
#
# We can define _1_ as
# - The longest possible sequence of whitespace, delimited comments,
#   newlines, and line comments, as long as it ends with a whitespace
#   or a delimited comment, because then it won't be in the first column.
#
# We can define _0_ as
# - _1_ or the empty string.
#
# We can define TLSS as
# - The longest possible sequence of whitespace, delimited comments,
#   newlines, and line comments, as long as it ends with a newline or EOF.
#
# PEG parsing tip: If we want to define a sequence like 'the longest
# sequence of As, Bs and Cs, as long as it ends with C' we define a short
# sequence like 'the longest sequence of As and Bs, then a C' and then
# define 'the longest sequence of those'.

_1_short <-
    (lineComment / NL)* (WS / delimitedComment)

_1_ <- _1_short+


_0_ <- _1_ / ''

TLSS_short <-
    (WS / lineComment / delimitedComment)* (NL / EOF)

TLSS <- TLSS_short+


%%
#include "elmish_post.h"
