# Copyright (c) 2022 Nik Silver
#
# This source code is released for free distribution under the terms of the
# GNU General Public License version 2 or later.
#
# Elmish tags format:
#   Kinds
#   - m module
#   - n namespace (ie a module that's renamed)
#   - t type
#   - c constructor (within a type)
#   - a alias
#   - p port
#   - f function
#   Key/value pairs
#   - roles:def    This tag is defined here
#   - roles:imported    This tag is imported here
#   - type:Thing    This constructor is of type Thing.
#
# To do:
# - Handle more variants of 'import' statement format.
# - For a constructor, reference its type (in import statement)
# - For a constructor, reference its type (in type definition)
# - Tag an anonymous function with an anonymous name
# - Symbolic binary operators: +, - >>, etc.
# - Symbolic functions as prefix notation: Eg (+) 1 2
# - Signatures for types
# - Signatures for constructors


%prefix "pelmish"

%auxil	"struct parserCtx *"

%earlysource {
    #include "general.h"
}

%header {
	struct parserCtx;
}

%source {
#include "elmish_pre.h"
#include "routines.h"

static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)
}

# Top level elements -----------------------------------------------------

# We separate the file into the module section and the main section
# so that we only consider and tag one module declaration

file <-
    moduleSection?
    mainSection
    EOF

moduleSection <- _* moduleDeclaration EOS

mainSection <-
    ( _
    / importStatement EOS
    / functionDefinition EOS
    / unparsable
    )*

unparsable <- <Non_WS+>

# Main Elm grammar -------------------------------------------------------

moduleDeclaration <-
    'module' _* <moduleIdentifier> _* ('exposing' _* '(' exposedList ')')? {
        PUSH_KIND(auxil, K_MODULE);
        makeElmTag(auxil, $1, $1s, K_MODULE, ROLE_DEFINITION_INDEX, true);
    }

importStatement <-
    'import' _* moduleIdentifier _* ('exposing' _* '(' _* importedList _* ')')?

functionDefinition <-
    <lowerStartIdentifier> _* <parameterList?> _* '=' _* expression {
        int r = makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_DEFINED, false);
        addElmSignature(r, $2);
    }

anonymousFunction <-
    '\\' _* parameterList? _* '->' _* expression

# Mid level tokens -------------------------------------------------------

# Module declaration
#
# We can be a bit relaxed about distinguishing functions, types and
# constructors, because we're not going to tag them.

moduleIdentifier <- upperStartIdentifier

exposedList <- _* exposedItem _* (',' _* exposedList _* )*

exposedItem <-
    exposedFieldOrType
    / exposedItemIgnored

exposedFieldOrType <-
    <identifier> ('(' _* exposedTypeConstructorList ')')?

exposedItemIgnored <- '.'+

exposedTypeConstructorList <-
    (identifier / exposedItemIgnored) _* (',' *_ exposedTypeConstructorList)*

# Import statement

importedList <- importedItem _* (',' *_ importedList)*

importedItem <-
    importedField
    / importedType
    / importedItemIgnored

importedField <- <lowerStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_IMPORTED, false);
    }

importedType <-
    <upperStartIdentifier> ('(' _* importedTypeConstructorList ')')? {
        makeElmTag(auxil, $1, $1s, K_TYPE, ELM_ROLE_IMPORTED, false);
    }

importedItemIgnored <- '.'+

importedTypeConstructorList <-
    (importedTypeConstructor / importedItemIgnored) _* (',' *_ importedTypeConstructorList)*

importedTypeConstructor <-
    <upperStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ELM_ROLE_IMPORTED, false);
    }

# For the signature field, we should exclude leading and trailing whitespace
#
parameterList <-
    ( literal _* parameterList )+
    / literal

expression <-
    '(' _* expression _* ')'
    / anonymousFunction
    / literal _* '+' _* literal
    / literal

# Low level tokens

identifier <- [A-Za-z_] [A-Za-z0-9_]*

upperStartIdentifier <- [A-Z] [A-Za-z0-9_]*

lowerStartIdentifier <- [a-z_] [A-Za-z0-9_]*

literal <- identifier / [0-9]+

# Ignorable things -------------------------------------------------------

# Some of these are a bit special.
# An Elm statement ends at the end of the line.
# An Elm statement continues if it's indented with at least as much
# whitespace as the statement began.

delimitedComment <- '{-' (delimitedComment / !'-}' .)* '-}'

lineComment <- '--' Non_NL*

# One non-empty ignorable unit
_ <- WS+ / NL / lineComment / delimitedComment

WS <- [ \t]+
NL <- '\n' / '\f' / '\r' '\n'?
Non_NL <- [^\n\r\f]
Non_WS <- [^ \t\n\r\f]
Ignore_To_EOL <- (WS / delimitedComment)* lineComment?
EOS <- Ignore_To_EOL? (NL / EOF)
EOF <- !.

%%
#include "elmish_post.h"
