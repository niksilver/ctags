# Copyright (c) 2022 Nik Silver
#
# This source code is released for free distribution under the terms of the
# GNU General Public License version 2 or later.
#
# Elmish tags format:
#   Kinds
#   - m module
#   - n namespace (ie a module that's renamed)
#   - t type
#   - c constructor (within a type)
#   - a alias
#   - p port
#   - f function
#   Key/value pairs
#   - roles:def    This tag is defined here
#   - roles:imported    This tag is imported here
#   - type:Thing    This constructor is of type Thing.
#
# To do:
# - Handle more variants of 'import' statement format.
# - For a constructor, reference its type (in import statement)
# - For a constructor, reference its type (in type definition)
# - Tag an anonymous function with an anonymous name
# - Symbolic binary operators: +, - >>, etc.
# - Symbolic functions as prefix notation: Eg (+) 1 2
# - Signatures for types
# - Signatures for constructors
# - Handle Elm indentation properly with regard to knowing when
#   a new statement starts, or the last one continues.


%prefix "pelmish"

%auxil	"struct parserCtx *"

%earlysource {
    #include "general.h"
}

%header {
	struct parserCtx;
}

%source {
#include "elmish_pre.h"
#include "routines.h"

static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)
}

# Top level elements -----------------------------------------------------

# We separate the file into the module section and the main section
# so that we only consider and tag one module declaration

file <-
    moduleSection?
    mainTopLevelStatements
    EOF

moduleSection <-
    moduleDeclaration
    / ignorableMultilines moduleDeclaration

mainTopLevelStatements <-
    topLevelStatement (TLSS mainTopLevelStatements)* TLSS?

topLevelStatement <-
    ignorableMultilines
    / importStatement
    / functionDefinition
    / unparsable

unparsable <- Non_WS_or_NL

# Main Elm grammar -------------------------------------------------------

moduleDeclaration <-
    'module' _1_ <moduleIdentifier> _1_ 'exposing' _0_ '(' exposedList ')' {
        PUSH_KIND(auxil, K_MODULE);
        makeElmTag(auxil, $1, $1s, K_MODULE, ROLE_DEFINITION_INDEX, true);
    }

importStatement <-
    'import' _1_ moduleIdentifier _1_ ('exposing' _0_ '(' _0_ importedList _0_ ')')?

functionDefinition <-
    <lowerStartIdentifier> _1_ <parameterList?> _0_ '=' _0_ expression {
        int r = makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_DEFINED, false);
        addElmSignature(r, $2);
    }

# anonymousFunction <-
#     '\\' _0_ parameterList? _0_ '->' _0_ expression

# Mid level tokens -------------------------------------------------------

# Module declaration
#
# We can be a bit relaxed about distinguishing functions, types and
# constructors, because we're not going to tag them.

moduleIdentifier <- upperStartIdentifier

exposedList <- _0_ exposedItem _0_ (',' _0_ exposedList )*

exposedItem <-
    exposedFieldOrType
    / exposedItemIgnored

exposedFieldOrType <-
    <identifier> (_0_ '(' _0_ exposedTypeConstructorList _0_ ')')?

exposedItemIgnored <- '.'+

exposedTypeConstructorList <-
    (identifier / exposedItemIgnored) _0_ (',' _0_ exposedTypeConstructorList)*

# Import statement

importedList <- importedItem _0_ (',' _0_ importedList)*

importedItem <-
    importedField
    / importedType
    / importedItemIgnored

importedField <- <lowerStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_IMPORTED, false);
    }

importedType <-
    <upperStartIdentifier> (_0_ '(' _0_ importedTypeConstructorList _0_ ')')? {
        makeElmTag(auxil, $1, $1s, K_TYPE, ELM_ROLE_IMPORTED, false);
    }

importedItemIgnored <- '.'+

importedTypeConstructorList <-
    (importedTypeConstructor / importedItemIgnored) _0_ (',' _0_ importedTypeConstructorList)*

importedTypeConstructor <-
    <upperStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ELM_ROLE_IMPORTED, false);
    }

# For the signature field, we should exclude leading and trailing whitespace
#
parameterList <-
    ( literal _1_ parameterList )+
    / literal

expression <- unparsable (_1_ expression)?
#     '(' _0_ expression _0_ ')'
#     / anonymousFunction
#     / literal _0_ '+' _0_ literal
#     / literal

# Low level tokens

identifier <- [A-Za-z_] [A-Za-z0-9_]*

upperStartIdentifier <- [A-Z] [A-Za-z0-9_]*

lowerStartIdentifier <- [a-z_] [A-Za-z0-9_]*

literal <- identifier / [0-9]+

# Ignorable things -------------------------------------------------------

# Simple things...

WS <- [ \t]+
NL <- '\n' / '\f' / '\r' '\n'?
Non_NL <- [^\n\r\f]
Non_WS_or_NL <- [^ \t\n\r\f]
EOF <- !.

# End of line marks the end of the line, but doesn't include any newline

EOL <- &NL / EOF

# A delimited comment is effectively "nothing", even if it spans several
# lines. But it does separate two tokens.
# A line comment can only come at the end of a line. Notice here it doesn't
# include the actual newline.

delimitedComment <- '{-' (delimitedComment / !'-}' .)* '-}'

lineComment <- '--' Non_NL*

# In this section, let's consider things only on the same line...
#
# Sometimes we need non-empty delineation between tokens, eg 'import MyModule'.
# When that's the case, all these are equivalent:
#
# import MyModule
# import{-...-}MyModule
# import{-...-}{-}MyModule
# import{-...-} {-}{--}MyModule
# import{-...-} {-}{--}  MyModule
#
# Sometimes the delineation can be empty, eg 'f = 3'.
# When that's the case, all these are equivalent:
#
# f = 3
# f= 3
# f{-...-}= 3
# f{-...-}{-}= 3
# f{-...-} {-}{--}= 3
# f{-...-} {-}{--}  = 3
#
# Let's call the first case _delin1_ and the second case _delin0_:

_delin1_ <- (WS / delimitedComment)+

_delin0_ <- _delin1_?

# Elm whitespacing is a bit special...
# - Two statements are at the same level (eg at the top level, or statements
#   in the same let...in block) only if they being with the same indentation.
# - If meaningful code has more indentation than the previous line then it is
#   part of that previous line's statement.
# - But sometimes several statements can appear on the same line if tokens
#   make it obvious. Eg this is okay:
#   Eg: 'myFunc = let f x y = x + y in f 3 4'
#
# We'll only worry about top level statements in this parser, otherwise it
# gets too complicated. (Something to improve for the future.) But we still
# need to know
# - when a top level statement begins; and
# - when two sequential tokens are part of the same top level statement.
#   They may be separated by a combination of whitespace, comments, and
#   newlines, but there will be an indent at the end.
#
# [1] So let's think how we define a multiline block in the case of something
# like 'import MyModule' where there does at least need to be some
# whitespace or delineation. It will be...
# - Some single line whitespace-equivalent, which is just _delin1_; or
# - [2] A series of ignorable lines separated by newlines, then a newline
#   (or several), then a non-empty indent. For flexibility, we should allow
#   that non-empty indent to include delimited comments, even though it's
#   bad style. SO that's a _delin1_ above
#
# Also, be aware that a line can always end with a line comment.
# So let first define an "ignorable line", which will only be used in the
# definition of [2] above.

ignorableLine <-
    lineComment EOL
    / _delin1_ lineComment? EOL

# Now the definition of 'a series of ignorable lines separated by
# newlines' from [2] above...

ignorableMultilines <-
    ignorableLine (NL+ ignorableMultilines)*

# And now the definiton of [2] above...

ignorableMultilinesAndIndent <-
    ignorableMultilines NL+ _delin1_

# And finally the "multiline block" from [1] above, which defines when
# something like 'import' and 'MyModule' are part of the same top level
# statement.

_1_ <- ignorableMultilinesAndIndent / _delin1_ 

# [3] Now let's think how we define a multiline block in the case of something
# like 'f = 3' where there doesn't need to be delineation, but could be.
# It will be...
# - Optionally whitespace-equivalent, which is just _delin0_; or
# - A series of ignorable lines separated by newlines, then a newline
#   (or several), then a non-empty indent.
#
# Following our definition of _1_ above, we can define this as

_0_ <- ignorableMultilinesAndIndent / _delin0_ 

# Now our top level statements are just a series of statements
# separated by ignorableMultilines and one or more newlines, and no indent.
# TLSS = top level level statement separator

TLSS <- ignorableMultilines? NL+


%%
#include "elmish_post.h"
