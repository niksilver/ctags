# Copyright (c) 2022 Nik Silver
#
# This source code is released for free distribution under the terms of the
# GNU General Public License version 2 or later.
#
# Elmish tags format:
#   Kinds
#   - m module
#   - n namespace (ie a module that's renamed)
#   - t type
#   - c constructor (within a type)
#   - a alias
#   - p port
#   - f function
#   Key/value pairs
#   - roles:def    This tag is defined here
#   - roles:imported    This tag is imported here
#   - type:Thing    This constructor is of type Thing.
#
# To do:
# - Records as type annotations and parameters
# - Custom types
#   - Allow records in type constructors
#   - Have type parameters as it signature
# - Tag ports
# - Constructor
#   - Reference its type (in import statement)
#   - Reference its type (in type definition)
#   - Add signatures to constructors
# - Functions
#   - Move the signature from the function to the
#     type annotation
# - Expand upper/lower case beyond just the Latin alphabet


%prefix "pelmish"

%auxil	"struct parserCtx *"

%earlysource {
    #include "general.h"
}

%header {
	struct parserCtx;
}

%source {
#include "elmish_pre.h"
#include "routines.h"

static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };

// From https://github.com/arithy/packcc#macros
// This will output parsing info to STDERR.tmp in the vent of a failed test.

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)
}

# Top level elements -----------------------------------------------------

# We separate the file into the module section and the main section
# so that we only consider and tag one module declaration

file <-
    TLSS?
    moduleDeclaration?
    TLSS?
    mainTopLevelStatements?
    TLSS?
    EOF

mainTopLevelStatements <-
    topLevelStatement (TLSS mainTopLevelStatements)*

topLevelStatement <-
    importStatement
    / typeAlias
    / customType
    / functionDefinition
    / unparsableStatement

# Main Elm grammar -------------------------------------------------------

moduleDeclaration <-
    'module' _1_ <identifier> _1_ 'exposing' _0_ '(' exposedList ')' {
        PUSH_KIND(auxil, K_MODULE);
        makeElmTag(auxil, $1, $1s, K_MODULE, ROLE_DEFINITION_INDEX, true);
    }

typeAlias <-
    'type' _1_ 'alias' _1_ <identifier> _0_ '=' _0_ expression {
        makeElmTag(auxil, $1, $1s, K_ALIAS, ROLE_DEFINITION_INDEX, false);
    }

customType <-
    'type' _1_ <identifier> (_0_ typeParameterList)? _0_ '=' _0_ {
        makeElmTag(auxil, $1, $1s, K_TYPE, ROLE_DEFINITION_INDEX, true);
    } constructorList {
        POP_KIND(auxil, true);
    }

importStatement <-
    'import' _1_ identifier _1_ ('exposing' _0_ '(' _0_ importedList _0_ ')')?

functionDefinition <-
    <identifier> _0_ <parameterList?> _0_ '=' _0_ expression {
        int r = makeElmTag(auxil, $1, $1s, K_FUNCTION, ROLE_DEFINITION_INDEX, false);
        addElmSignature(r, $2);
    }

unparsableStatement <-
    (multilineString / Non_WS_or_NL+) (_1_ unparsableStatement)*

# Mid level tokens -------------------------------------------------------

# Module declaration
#
# We can be a bit relaxed about distinguishing functions, types and
# constructors, because we're not going to tag them.

exposedList <- _0_ exposedItem _0_ (',' _0_ exposedList )*

exposedItem <-
    exposedFieldOrType
    / exposedItemIgnored

exposedFieldOrType <-
    <identifier> (_0_ '(' _0_ exposedTypeConstructorList _0_ ')')?

exposedItemIgnored <- '.'+

exposedTypeConstructorList <-
    (identifier / exposedItemIgnored) _0_ (',' _0_ exposedTypeConstructorList)*

# Import statement

importedList <- importedItem _0_ (',' _0_ importedList)*

importedItem <-
    importedField
    / importedType
    / importedItemIgnored

importedField <- <lowerStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_FUNCTION, ELM_ROLE_IMPORTED, false);
    }

importedType <-
    <upperStartIdentifier> (_0_ '(' _0_ importedTypeConstructorList _0_ ')')? {
        makeElmTag(auxil, $1, $1s, K_TYPE, ELM_ROLE_IMPORTED, false);
    }

importedItemIgnored <- '.'+

importedTypeConstructorList <-
    (importedTypeConstructor / importedItemIgnored) _0_ (',' _0_ importedTypeConstructorList)*

importedTypeConstructor <-
    <upperStartIdentifier> {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ELM_ROLE_IMPORTED, false);
    }

# Type parameters, such as 'x' in 'type MyType x = Wrap x'
# We will be forgiving about capitalisation, although the compiler
# will insist on lower case parameter identifiers.

typeParameterList <- identifier (_1_ identifier)*

constructorList <- <identifier> (_1_ constructorParameters)? _0_ ('|' _0_ constructorList)? {
        makeElmTag(auxil, $1, $1s, K_CONSTRUCTOR, ROLE_DEFINITION_INDEX, false);
}

constructorParameters <- identifier (_1_ identifier)*

# For the signature field, we should exclude leading and trailing whitespace

parameterList <-
    ( literal _1_ parameterList )+
    / literal

expression <- unparsableStatement

multilineString <-
    '"""' (!'"""' .)* '"""'

# Low level tokens

identifier <- [A-Za-z_] [A-Za-z0-9_]*

upperStartIdentifier <- [A-Z] [A-Za-z0-9_]*

lowerStartIdentifier <- [a-z_] [A-Za-z0-9_]*

literal <- identifier / [0-9]+

# Ignorable things -------------------------------------------------------

# Simple things...

WS <- [ \t]+
NL <- '\n' / '\f' / '\r' '\n'?
Non_NL <- [^\n\r\f]
Non_WS_or_NL <- [^ \t\n\r\f]
EOF <- !.

# End of line marks the end of the line, but doesn't include any newline

# EOL <- &NL / EOF

# A delimited comment is effectively "nothing", even if it spans several
# lines. But it does separate two tokens.
# A line comment can only come at the end of a line. Notice here it doesn't
# include the actual newline.

delimitedComment <- '{-' (delimitedComment / !'-}' .)* '-}'

lineComment <- '--' Non_NL*

# Elm whitespacing is a bit special...
# - Two statements are at the same level (eg at the top level, or statements
#   in the same let...in block) only if they being with the same indentation.
# - If meaningful code has more indentation than the previous line then it is
#   part of that previous line's statement.
# - But sometimes several statements can appear on the same line if tokens
#   make it obvious. Eg this is okay:
#   Eg: 'myFunc = let f x y = x + y in f 3 4'
#
# We'll only worry about top level statements in this parser, otherwise it
# gets too complicated. (Something to improve for the future.) But we still
# need to know
# - when a top level statement begins; and
# - when two sequential tokens are part of the same top level statement.
#   They may be separated by a combination of whitespace, comments, and
#   newlines, but there will be an indent at the end.
#
# When considering how tokens string together, we should only need three
# kinds of "join"s:
# - Where we need whitespace, such as 'import MyModule', but that space
#   may occur over multiple lines. If it's over multiple lines, the
#   second token needs to be somewhat in from the first column of text.
#   We'll call this _1_.
# - Where we don't need whitespace, such as 'f = 3', but that space
#   may occur over multiple lines. If it's over multiple lines then again
#   the second token needs to be somewhat in from the first column of text.
#   We'll call this _0_.
# - When we've got an end of statement, and the second token is some
#   meaningful code (not a comment) and starts in the first column of text.
#   We'll call this TLSS, for top level statement separator.
#
# We can define _1_ as
# - The longest possible sequence of whitespace, delimited comments,
#   newlines, and line comments, as long as it ends with a whitespace
#   or a delimited comment, because then it won't be in the first column.
#
# We can define _0_ as
# - _1_ or the empty string.
#
# We can define TLSS as
# - The longest possible sequence of whitespace, delimited comments,
#   newlines, and line comments, as long as it ends with a newline or EOF.
#
# PEG parsing tip: If we want to define a sequence like 'the longest
# sequence of As, Bs and Cs, as long as it ends with C' we define a short
# sequence like 'the longest sequence of As and Bs, then a C' and then
# define 'the longest sequence of those'.

_1_short <-
    (lineComment / NL)* (WS / delimitedComment)

_1_ <- _1_short+


_0_ <- _1_ / ''

TLSS_short <-
    (WS / lineComment / delimitedComment)* (NL / EOF)

TLSS <- TLSS_short+


%%
#include "elmish_post.h"
